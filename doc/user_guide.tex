\documentclass[11pt,preprint]{aastex}

\newcommand{\param}[2]{\medskip\noindent{\bf #1:} (#2) }
\newcommand{\todo}[1]{{\bf TODO: #1}}
\newcommand{\future}[1]{{\it Future: #1}}

\newcommand{\fdir}[1]{\noindent\makebox[4in][l]{#1}}

\begin{document}
\title{ABACUS User Guide}
\author{\today}

\section{Introduction to Abacus}

Abacus is a cosmology N-body code intended for large cosmological
simulations with high-force accuracy.  It utilizes fast near-field
computations using GPUs and AVX instructions, as well as a novel
method for solving the far field.

The Abacus computation is organized into a 3-dimensional grid of
cells.  Particles belong to cells.  The near-field force is computed
within a cell and its near neighbors.  Set finding also happens
within a fixed maximum number of cells.  The far-field force is
computed from the multipole moments of particles in the cells.

Abacus is built to run out-of-core, so that the particles are read
only once per full time step.  The computation occurs through a
pipeline that takes a 1-dimensional sweep through the simulation
volume.  The plane of cells perpendicular to the sweep direction
are called a slab.  This is the $x$ direction in the simulation
units.

Abacus evolves through a series of states.  Every full time step
reads a state, evolves the particles, and then writes a new state.
The states are the restart files.  Because of the leapfrog time
evolution, the states are generally not time-synchronous between
the positions and velocities: the velocities will require an
additional kick by the listed kick factor to be synchronous with
the positions.

Because of this leapfrogging, the state files are generally not
intended for long-term storage of the outputs.  Instead, Abacus
generates output files during full steps.  Time slice outputs will
occur at the redshift of the ``read'' state (so the full time step
will be shortened so as not to overshoot the requested time slice).
Light cone outputs are interpolated to the time when the past light
cone from an observer crosses the particle or the coevolution set.

Within a full step, microstepping may occur.  This means that
particles in higher density regions with shorter dynamical times
will use shorter leapfrog steps.  However, to avoid needing to load
the particles more than once from disk, the regions requiring finer
time steps are identified on the fly so that all of the microsteps
occur at once.  The regions requiring mutually finer time resolution
of the forces are known as coevolution sets.  By definition, all
particles outside of a given coevolution set have forces that are
sufficiently constant over the full step as to be applied with only
the top-level leapfrog.  Note that one can always pick a short
enough full time-step to satisfy one's accuracy criterion for this.
Inside the coevolution set, a variety of time steps may be used.

In addition to their utility in time stepping, co-evolution sets
also define the maximum boundaries of our halo and subhalo finding.
In other words, halo finding never extends beyond the set boundary.
Finally, co-evolution sets are cohesive for light-cone outputs: we
will always output a snapshot of a co-evolution set at the ``read''
state epoch, but shifting the center of mass position and velocity
drift to the exact epoch when the past light cone sweeps by.

Coevolution sets are found by performing friends-of-friends with a
fairly large linking length.

\section{Coevolution Sets and Group Finding}

More on co-evolution sets.

\section{Light cone Outputs}

Describe light cones here.


\section{Parameter file description}

The parameter file holds values that should be constant throughout the
simulation.  In principle, one could change the file when restarting
from a state, but behavior is not guaranteed.  Still, this could be
useful for adjusting output parameters, for example.

Values that change with time as the simulation evolves or that are 
calculated by the abacus code or cosmology module are in the state
file.

Both headers are incorporated into output file headers. 

\subsection{Basic simulation parameters}

\param{NP}{long long int} The number of particles in the simulation.
Note that math is allowed in inputs to GenParam, so you might opt to
set this to a perfect cube, e.g., to 1024**3.

\param{CPD}{int} The cells per dimension.  This number must be odd.

\param{BoxSize}{float} The size of the box in physical units.

\param{hMpc}{int} =1 if we're using Mpc/h units.  =0 if Mpc units.

\param{TimeStepAccel}{float} Time-step parameter based on accelerations.
\todo{Was called Eta.}

\param{TimeStepDlna}{float} Maximum $\Delta(\ln a)$ allowed for a full step.
\todo{Was called Dlna.}

\param{FinalRedshift}{float} The final redshift of the simulation.
If not supplied, then we use the lowest redshift TimeSlice output.
However, one might want to run further to complete light cones.

\subsection{Set and Group Finding}

\param{GroupRadius}{int} The maximum size of a coevolution set, 
in units of cells (i.e., BoxSize/cpd).


\subsection{Memory Allocation and other Execution Parameters}

\param{NumSlabsInsertList}{float} The amount of space to allocate for
the insert list.  This is supplied as a multiple (not necessarily integral)
of np/cpd particles, i.e., the average number of particles per slab.
The default is 2.

\param{NumSlabsInsertListIC}{float} The amount of space to allocate
for the insert list in the initial ingestion of IC particles.  Here
we typically have much less memory required elsewhere in the code.  
Again, this is supplied as a multiple of np/cpd particles, i.e., the
average number of particles per slab.  Choosing 0 causes this parameter
to be set to cpd, so that the insert list can contain all of the particles
in the simulation.  This is appropriate for small problems where the
particles aren't sorted into slabs in the IC file.  For large problems,
one should use at least 4.  Default is 4.


\subsection{Far-field parameters}

\param{order}{int} The multipole order to use for the far-field.  Typical
choices would be 8 or 16.  One really should not use low orders such
as 2!

\param{DerivativeExpansionRadius}{int} The number of periodic replicas
to sum over explicitly before switching to the asymptotic value.
\todo{Suggest a good value!}
\todo{Is this the right definition?}

\param{MAXConvolutionRAMMB}{int} \todo{Don't know what this is.  Should
we really be phrasing our memory limit this way?  Perhaps we should be
saying how much memory we have available and let the driver code figure
out how much to use for this.}

\param{ConvolutionCacheSizeMB}{int} \todo{See previous.}

\param{DerivativesDirectory}{string} The directory where the derivative
files are stored.  One expects to reuse derivatives between
simulations, rather than regenerating them each time.  The derivative
files are about 1/16 the size of the multipoles, so one would like
the I/O rate on this device to be 1/32 of the rate of the device
for the multipoles and Taylors.  Because the derivative files are
not slab-ordered, the latency issue is much reduced.  So in many
cases, the derivatives can be stored on a normal hard disk.  
\future{Is this true?}


\subsection{Near-field parameters}

\param{NearFieldRadius}{int} The radius of cells to be solved in the
near-field.  Radius 1 means that each cell is acted on by itself and
26 neighbors.  Radius 2 means 124 neighbors.  One really should not
use radius 0!

\param{SofteningLength}{float} The softening length used in the near-field
force.  

\param{DirectNewtonRaphson}{int} Choice of 1 means that we use a
Newton-Raphson step to improve the precision of the forces.
\future{Is this really a choice that we want to offer?}

\future{We will eventually have parameters for choices of softening model, 
trees, etc.}


\subsection{State Directories}

\param{WorkingDirectory}{string} Unless countermanded by the choices below,
this is where the states will be created.  This should be a very fast disk.

\param{ReadStateDirectory}{string} The name of the read state directory.
Starting the name with + indicates a path from the WorkingDirectory.
This defaults to ``+read''.

\param{WriteStateDirectory}{string} The name of the write state directory.
Starting the name with + indicates a path from the WorkingDirectory.
This defaults to ``+write''.

\param{PastStateDirectory}{string} The name of the past state directory.
Starting the name with + indicates a path from the WorkingDirectory.
This defaults to ``+past''.


\subsection{Initial Conditions}

\param{InitialRedshift}{float} The initial redshift of the simulation.

\param{LagrangianPTOrder}{int} Instruction for how to use the initial 
Zel'dovich dispacements.  =1 for Zel'dovich, =2 for 2LPT, =3 for 3LPT.
The higher-order Lagrangian Perturbation Theory is performed by using
Abacus to compute forces, which then get scaled to the LPT displacements
at the given redshift.  See doc/lpt.pdf for more detail.

\param{InitialConditionsDirectory}{string} The directory where the 
initial condition files will be found.  This defaults to ReadStateDirectory.

These files must be named ``IC\_0000'', ``IC\_0001'', etc.  The number
indicates the slab number; file $N-1$, $N$, and $N+1$ will be read
before slab $N$ is finished.  File $N=0$ is the first file read;
slab 1 is the first slab finished.  This means that the particles
in slab $N$ must appear no later than file $N+1$.  However, if the
particles appear in a much earlier file, then the insert list will
become very large.  This is acceptable if the simulation fits entirely
into memory.  For large sims, we expect that the particles will be 
sorted into slabs, with no more than $\pm 1$ tolerance.  This tolerance
is likely sufficient, e.g., for Zel'dovich displacements, so that particles
can be placed in slab files by their grid position rather than their
true initial position.

\param{ICFormat}{string} The format of the IC files. \todo{List these.}

\param{ICPositionRange}{float} The size of the periodic box for the 
IC positions, in the units supplied in the IC file.  For example, 
ICPositionRange of 1 means that the positions are all 0..1.  A choice
of 0 causes this parameter to be set equal to BoxSize.

\param{ICVelocity2Displacement}{float} The conversion factor by which
to multiply the supplied velocities so as to convert them to redshift-space
comoving displacements, in the same units as the supplied positions (see
ICPositionRange) and at the initial redshift.


\subsection{Output Parameters}

\param{SimName}{string} The name of the simulation, intended to be unique
for each simulation.  This is used both as the primary path of the directory
where output will occur, but also in filenames.

\param{ParentDirectory}{string} The directory where the outputs are to
be placed.  This defaults to WorkingDirectory, but often would be on
a different (more long-term stable) disk.  

\param{OutputDirectory}{string} This is where the outputs will be
placed; in particular, the time slices will be here.  Starting the
name with + indicates a path from ParentDirectory.  The default is
+SimName, i.e., ParentDirectory/SimName, so that multiple simulations
of the same set can share the same ParentDirectory.

\param{LogDirectory}{string} The directory where the logs are to be
stored.  Starting the name with + indicates a path from 
OutputDirectory.  The default is ``+log".  Each time step
generates several log files, but these all go in the same directory.
\todo{Was LogFileDirectory.}

\param{LightConeDirectory}{string} The directory where the light
cones should get written.  Starting the name with + indicates a path
from OutputDirectory.  The default is ``+lc''.  The number
of the light cone 0..7 will get postpended to the name, so if you give
a value here you probably don't want a trailing slash.  
Inside this directory, the outputs will be further divided with one 
subdirectory per time step; these names are fixed to be ``stepNNNN''.

\param{GroupDirectory}{string} The directory where group information
will be written.  Starting the name with + indicates a path from
OutputDirectory.  The default is ``+groups''.  Inside this directory,
the outputs will be further divided with one subdirectory per time
step; these names are fixed to be ``stepNNNN''.


\param{nTimeSlice}{int} The number of time slice outputs.

\param{TimeSliceRedshift}{float vector} The redshift of the requested 
time slices.  When redshifts appear in file names, it will be as ``z\%5.3f''.
\todo{Was named TimeSlicez}.


\param{NLightCones}{int} The number of light cones.  We support up to 8.

\param{LightConeOrigins}{float vector} The observation point
of the light cones, in triples $(x,y,z)$.  Up to eight light cones 
can be supplied.  The position need not be inside the primary 
wrapping of the box.  The position should be in the same unit
as BoxSize.


\todo{Delete GroupFilePrefix, TimeSliceFilePrefix, LightFilePrefix.  
We will hardcode these names.}


These choices produce the following hierarchy of files:

\fdir{ParentDirectory}			(default to WorkingDirectory)

\fdir{ParentDirectory/RunName}		(aka OutputDirectory) \\
ParentDirectory/RunName/sliceZ.ZZZ/RunName.zZ.ZZZ.slabNNNN.php14

\fdir{ParentDirectory/RunName/log}	(aka LogDirectory) \\
ParentDirectory/RunName/log/RunName.stepNNNN.log \\
ParentDirectory/RunName/log/RunName.stepNNNN.iolog \\
ParentDirectory/RunName/log/RunName.stepNNNN.timing \\
ParentDirectory/RunName/log/RunName.stepNNNN.convolve

\fdir{ParentDirectory/RunName/group}	(aka GroupDirectory) \\
ParentDirectory/RunName/group/stepNNNN/RunName.stepNNNN.slabNNNN.grp

\fdir{ParentDirectory/RunName/lcN}	(aka LightConeDirectory + N) \\
ParentDirectory/RunName/lcN/stepNNNN/RunName.lcN.stepNNNN.slabNNNN.php14

The RunName is used both in the output path and as the file name prefix.
Redshifts are written in names with format \%5.3f.
Slabs and Steps are written with \%04d.
Light cones are written with \%1d.

The php14 suffix is just a place-holder, but this is to indicate the 
file format.


\subsection{Cosmological parameters}

\param{H0}{float} The Hubble constant in km/s/Mpc

\param{Omega\_M}{float} At $z=0$.

\param{Omega\_DE}{float} At $z=0$.

\param{Omega\_K}{float} At $z=0$.

\param{w0}{float} Dark energy equation of state $w(z) = w_0 + (1-a)*w_a$.

\param{wa}{float} See above.


\subsection{Debugging and Special Cases}

\param{StoreForces}{int} If 1, store the accelerations in the OutputDirectory.

\param{ForceOutputDebug}{int} If 1, output near and far forces
seperately.  The time step is set to zero, so there is no other
action and other outputs (e.g., group finding) may be garbled.
Should only be set if StoreForces is not set.

In addition, using TimeStepDlna=0 forces the next time step to be 0, which
implies that the particles won't advance (although forces and groups
will still be computed).

\subsection{Zel'dovich parameters}

\end{document}
\section{State values}

The State file contains information that is computed by the Abacus code,
particularly values that are epoch-dependent.

\param{np\_state, cpd\_state, order\_state}{int} These are just
copied from the parameter file, so that we can be sure to be able
to read the state files.

\param{ParameterFileName}{string} The name of the Parameter file
on which the state was invoked.

\param{CodeVersion}{string} The git hash label of the executable.

\param{RunTime}{string} The time stamp of the start of this invocation
of singlestep().

\param{MachineName}{string} The machine name where this step is
being run.

\param{ppd}{double} The cube root of the number of particles.  We
take care to round this off to an integer if it is very close.

\param{DoublePrecision}{int} Whether the internal positions,
velocities, and forces are being computed in single precision (==0)
or double precision (==1).

\param{FullStepNumber}{int} The full step number.  The initial
conditions get translated into a state (with multipoles) that is
defined as step number 0.  So the full step number is also the
number of times that full forces have been computed.

\param{BoxSizeMpc, BoxSizeHMpc}{double} The comoving size of the
box, in Mpc and $h^{-1}$ Mpc.

\param{HubbleTimeGyr, HubbleTimeHGyr}{double} The value of $1/H_0$
in Gyr and $h^{-1}$ Gyr.  This is important because all of the times
below will be reported in units of $H_0=1$.

\param{ParticleMassMsun, ParticleMassHMsun}{double} The mass of a
single particle, in $M_\odot$ and $h^{-1}\ M_\odot$.

\subsection{Properties of the Epoch}

\param{ScaleFactor}{double} The scale factor $a$, normalized to $a=1$ 
at the present day.

\param{Redshift}{double} The redshift $1+z = 1/a$.

\param{RedshiftSpaceConversion}{double} The Hubble velocity across
the full box in km/s.  In other words, this is $H(z)L/(1+z)$, in
km/s.  If one has velocities in redshift-space displacement unit-box 
units (our default), then multiplying by this factor will convert the
velocity to km/s.

\param{VelZSpace_to_Canonical}{double} The conversion from our basic
output velocity unit of redshift-space displacement (in unit box
length units) to the code canonical velocities.
\todo{Dig up this formula}

\param{Time}{double} The proper time, in $1/H_0$ units.

\param{etaK}{double} The integral $\int_0^t dt/a$, which is used
in kicking the particles.  This is also the conformal time.  In
$1/H_0$ units.

\param{etaD}{double} The integral $\int_0^t dt/a^2$, which is used
in drifting the particles.  In $1/H_0$ units.  \todo{Check boundaries
of integral}

\param{Growth}{double} The linear growth function, normalized to $a$ at early times.

\param{Growth_on_a}{double} The linear growth function divided by
$a$, which is unity in Einstein-de Sitter.

\param{f_growth}{double} The growth rate $d\ln D/d\ln a$.

\param{w}{double} The equation of state of dark energy at the present epoch.

\param{HubbleNow}{double} The Hubble parameter at the current epoch,
in $H_0$ units, i.e., $H(z)/H_0$.

\param{Htime}{double} The product of the Hubble parameter and the
current time, $H(z) t(z)$.  This is 2/3 in Einstein-de Sitter.

\param{OmegaNow_m}{double} The value of $\Omega_m$ that an observer
at this epoch would measure.

\param{OmegaNow_K}{double} The value of $\Omega_K$ that an observer
at this epoch would measure.

\param{OmegaNow_DE}{double} The value of $\Omega_{DE}$ that an
observer at this epoch would measure.

\subsection{Properties of the Timestep}

\param{DeltaTime}{double} The time difference between this state
and the previous one.

\param{DeltaScaleFactor}{double} The scale factor difference between
this state and the previous one.

\param{DeltaRedshift}{double} The redshift difference between this
state and the previous one.  \todo{Is this positive or negative?}

\param{ScaleFactorHalf}{double} The scale factor of the time halfway
between this state and the previous one.

\param{LastHalfEtaKick}{double} The $\Delta\eta_K$ kick that remains
to be applied to the velocities in this state to bring them up to
the epoch in this state.  Recall that the velocities are stored a 
half-step before and will be leaped over to be a half-step ahead, 
before they are drifted again.  Note that when the particles are in
the Read state, this is the $\Delta\eta_K$ we will apply, yet we 
no longer have access to the state epoch {\it before} this Read state,
hence the need to save this quantity.

\param{FirstHalfEtaKick}{double} The $\Delta\eta_K$ kick that will
be applied to move the velocities halfway from the previous epoch
to the current epoch.

\param{DeltaEtaDrift}{double} The $\Delta\eta_D$ drift that will
be applied to move the positions from the previous epoch
to the current epoch.

\subsection{Statistics of the particle distribution}
These are used to compute the time step and to monitor the code.

\param{MaxVelocity}{float}

\param{MaxAcceleration}{float}

\param{MinVrmsOnAmax}{float}
\todo{Why are these still floats?  DJE should check.}

\param{MaxCellSize}{int}

\param{MinCellSize}{int}

\param{StdDevCellSize}{double}

\param{RMS_Velocity}{double}

\end{document}
